assert assert(int expression) [void]\nMacro used for internal error detection. (Ignored if NDEBUG is defined where <assert.h> is\nincluded.) If `expression` equals zero, message printed on stderr and abort called to terminate\nexecution. Source filename and line number in message are from preprocessor macros __FILE__\nand __LINE__.\n

isalnum isalnum(int c) [int]\nisalpha(c) or isdigit(c)\n
isalpha isalpha(int c) [int]\nisupper(c) or islower(c)\n
iscntrl iscntrl(int c) [int]\nis control character. In ASCII, control characters are 0x00 (NUL) to 0x1F (US), and 0x7F (DEL)\n
isdigit isdigit(int c) [int]\nis decimal digit\n
isgraph isgraph(int c) [int]\nis printing character other than space\n
islower islower(int c) [int]\nis lower-case letter\n
isprint isprint(int c) [int]\nis printing character (including space). In ASCII, printing characters are 0x20 (' ') to 0x7E ('~')\n
ispunct ispunct(int c) [int]\nis printing character other than space, letter, digit\n
isspace isspace(int c) [int]\nis space, formfeed, newline, carriage return, tab, vertical tab\n
isupper isupper(int c) [int]\nis upper-case letter\n
isxdigit isxdigit(int c) [int]\nis hexadecimal digit\n
tolower tolower(int c) [int]\nreturn lower-case equivalent\n
toupper toupper(int c) [int]\nreturn upper-case equivalent\n

errno errno\nobject to which certain library functions assign specific positive values on\nerror\n
EDOM EDOM\ncode used for domain errors\n
ERANGE ERANGE\ncode used for range errors\n

FLT_RADIX FLT_RADIX\nradix of floating-point representations\n
FLT_ROUNDS FLT_ROUNDS\nfloating-point rounding mode\n

FLT_DIG FLT_DIG\nprecision of float (in decimal digits)\n
DBL_DIG DBL_DIG\nprecision of double (in decimal digits)\n
LDBL_DIG LDBL_DIG\nprecision of long double (in decimal digits)\n

FLT_EPSILON FLT_EPSILON\nsmallest float number x such that 1.0 + x != 1.0\n
DBL_EPSILON DBL_EPSILON\nsmallest double number x such that 1.0 + x != 1.0\n
LDBL_EPSILON LDBL_EPSILON\nsmallest long double number x such that 1.0 + x != 1.0\n

FLT_MANT_DIG FLT_MANT_DIG\nnumber of float digits, base FLT_RADIX, in mantissa\n
DBL_MANT_DIG DBL_MANT_DIG\nnumber of double digits, base FLT_RADIX, in mantissa\n
LDBL_MANT_DIG LDBL_MANT_DIG\nnumber of long double digits, base FLT_RADIX, in mantissa\n

FLT_MAX FLT_MAX\nmaximum float number\n
DBL_MAX DBL_MAX\nmaximum double number\n
LDBL_MAX LDBL_MAX\nmaximum long double number\n

FLT_MAX_EXP FLT_MAX_EXP\nlargest positive integer exponent to which FLT_RADIX can be raised and remain representable\n
DBL_MAX_EXP DBL_MAX_EXP\nlargest positive integer exponent to which FLT_RADIX can be raised and remain representable\n
LDBL_MAX_EXP LDBL_MAX_EXP\nlargest positive integer exponent to which FLT_RADIX can be raised and remain representable\n

FLT_MIN FLT_MIN\nminimum normalised float number\n
DBL_MIN DBL_MIN\nminimum normalised double number\n
LDBL_MIN LDBL_MIN\nminimum normalised long double number\n

FLT_MIN_EXP FLT_MIN_EXP\nsmallest negative integer exponent to which FLT_RADIX can be raised and remain representable\n
DBL_MIN_EXP DBL_MIN_EXP\nsmallest negative integer exponent to which FLT_RADIX can be raised and remain representable\n
LDBL_MIN_EXP LDBL_MIN_EXP\nsmallest negative integer exponent to which FLT_RADIX can be raised and remain representable\n

CHAR_BIT CHAR_BIT\nnumber of bits in a char\n
CHAR_MAX CHAR_MAX\nmaximum value of type char\n
CHAR_MIN CHAR_MIN\nminimum value of type char\n
SCHAR_MAX SCHAR_MAX\nmaximum value of type signed char\n
SCHAR_MIN SCHAR_MIN\nminimum value of type signed char\n
UCHAR_MAX UCHAR_MAX\nmaximum value of type unsigned char\n
SHRT_MAX SHRT_MAX\nmaximum value of type short\n
SHRT_MIN SHRT_MIN\nminimum value of type short\n
USHRT_MAX USHRT_MAX\nmaximum value of type unsigned short\n
INT_MAX INT_MAX\nmaximum value of type int\n
INT_MIN INT_MIN\nminimum value of type int\n
UINT_MAX UINT_MAX\nmaximum value of type unsigned int\n
LONG_MAX LONG_MAX\nmaximum value of type long\n
LONG_MIN LONG_MIN\nminimum value of type long\n
ULONG_MAX ULONG_MAX\nmaximum value of type unsigned long\n

lconv lconv [struct]\nDescribes formatting of monetary and other numeric values Implementations may change field\norder and include additional fields. Standard C Library functions use only `decimal_point`.\n
decimal_point lconv.decimal_point [char*]\ndecimal point for non-monetary values\n
grouping lconv.grouping [char*]\nsizes of digit groups for non-monetary values\n
thousands_sep lconv.thousands_sep [char*]\nseparator for digit groups for non-monetary values (left of "decimal point")\n
currency_symbol lconv.currency_symbol [char*]\ncurrency symbol\n
int_curr_symbol lconv.int_curr_symbol [char*]\ninternational currency symbol\n
mon_decimal_point lconv.mon_decimal_point [char*]\ndecimal point for monetary values\n
mon_grouping lconv.mon_grouping [char*]\nsizes of digit groups for monetary values\n
mon_thousands_sep lconv.mon_thousands_sep [char*]\nseparator for digit groups for monetary values (left of "decimal point")\n
negative_sign lconv.negative_sign [char*]\nnegative sign for monetary values\n
positive_sign lconv.positive_sign [char*]\npositive sign for monetary values\n
frac_digits lconv.frac_digits [char]\nnumber of digits to be displayed to right of "decimal point" for monetary values\n
int_frac_digits lconv.int_frac_digits [char]\nnumber of digits to be displayed to right of "decimal point" for international monetary values\n
n_cs_precedes lconv.n_cs_precedes [char]\nwhether currency symbol precedes (1) or follows (0) negative monetary values\n
n_sep_by_space lconv.n_sep_by_space [char]\nwhether currency symbol is (1) or is not (0) separated by space from negative monetary values\n
n_sign_posn lconv.n_sign_posn [char]\nformat for negative monetary values:\n\n  * 0: parentheses surround quantity and currency symbol\n  * 1: sign precedes quantity and currency symbol\n  * 2: sign follows quantity and currency symbol\n  * 3: sign immediately precedes currency symbol\n  * 4: sign immediately follows currency symbol\n
p_cs_precedes lconv.p_cs_precedes [char]\nwhether currency symbol precedes (1) or follows (0) positive monetary values\n
p_sep_by_space lconv.p_sep_by_space [char]\nwhether currency symbol is (1) or is not (0) separated by space from non-negative monetary values\n
p_sign_posn lconv.p_sign_posn [char]\nformat for non-negative monetary values, with values as for n_sign_posn\n

localeconv localeconv(void) [lconv*]\nreturns pointer to formatting information for current locale\n
setlocale setlocale(int category, const char* locale) [char*]\nSets components of locale according to specified `category` and `locale`.  Returns string\ndescribing new locale or null on error. (Implementations are permitted to define values of\n`category` additional to those describe here.)\n
LC_ALL LC_ALL\ncategory argument for all categories\n
LC_NUMERIC LC_NUMERIC\ncategory for numeric formatting information\n
LC_MONETARY LC_MONETARY\ncategory for monetary formatting information\n
LC_COLLATE LC_COLLATE\ncategory for information affecting collating functions\n
LC_CTYPE LC_CTYPE\ncategory for information affecting character class tests functions\n
LC_TIME LC_TIME\ncategory for information affecting time conversions functions\n
NULL NULL\nnull pointer constant\n

HUGE_VAL HUGE_VAL\nmagnitude returned (with correct sign) on overflow error\n
exp exp(double x) [double]\nexponential of `x`\n
log log(double x) [double]\nnatural logarithm of `x`\n
log10 log10(double x) [double]\nbase-10 logarithm of `x`\n
pow pow(double x, double y) [double]\n`x` raised to power `y`\n
sqrt sqrt(double x) [double]\nsquare root of `x`\n
ceil ceil(double x) [double]\nsmallest integer not less than `x`\n
floor floor(double x) [double]\nlargest integer not greater than `x`\n
fabs fabs(double x) [double]\nabsolute value of `x`\n
ldexp ldexp(double x, int n) [double]\n`x` times 2 to the power `n`\n
frexp frexp(double x, int* exp) [double]\nif `x` non-zero, returns value, with absolute value in interval [1/2, 1), and assigns to `*exp`\ninteger such that product of return value and 2 raised to the power `*exp` equals `x`; if `x`\nzero, both return value and `*exp` are zero\n
modf modf(double x, double* ip) [double]\nreturns fractional part and assigns to `*ip` integral part of `x`, both with same sign as `x`\n
fmod fmod(double x, double y) [double]\nif `y` non-zero, floating-point remainder of `x`/`y`, with same sign as `x`; if `y` zero,\nresult is implementation-defined\n
sin sin(double x) [double]\nsine of `x`\n
cos cos(double x) [double]\ncosine of `x`\n
tan tan(double x) [double]\ntangent of `x`\n
asin asin(double x) [double]\narc-sine of `x`\n
acos acos(double x) [double]\narc-cosine of `x`\n
atan atan(double x) [double]\narc-tangent of `x`\n
atan2 atan2(double y, double x) [double]\narc-tangent of `y`/`x`\n
sinh sinh(double x) [double]\nhyperbolic sine of `x`\n
cosh cosh(double x) [double]\nhyperbolic cosine of `x`\n
tanh tanh(double x) [double]\nhyperbolic tangent of `x`\n

jmp_buf jmp_buf\ntype of object holding context information\n
setjmp setjmp(jmp_buf env) [int]\nSaves context information in `env` and returns zero. Subsequent call to longjmp with same `env`\nreturns non-zero.\n
longjmp longjmp(jmp_buf env, int val) [void]\nRestores context saved by most recent call to setjmp with specified `env`.  Execution resumes as\na second return from setjmp, with returned value `val` if specified value non-zero, or 1 otherwise.\n

SIGABRT SIGABRT\nabnormal termination\n
SIGFPE SIGFPE\narithmetic error\n
SIGILL SIGILL\ninvalid execution\n
SIGINT SIGINT\n(asynchronous) interactive attention\n
SIGSEGV SIGSEGV\nillegal storage access\n
SIGTERM SIGTERM\n(asynchronous) termination request\n
SIG_DFL SIG_DFL\nspecifies default signal handling\n
SIG_ERR SIG_ERR\nsignal return value indicating error\n
SIG_IGN SIG_IGN\nspecifies that signal should be ignored\n
raise raise(int sig) [int]\nSends signal sig. Returns zero on success.\n

va_list va_list\ntype of object holding context information\n
va_start va_start(va_list ap, lastarg) [void]\nInitialisation macro which must be called once before any unnamed argument is accessed. Stores\ncontext information in `ap`. `lastarg` is the last named parameter of the function.\n
va_arg va_arg(va_list ap, type) [type]\nYields value of the type (`type`) and value of the next unnamed argument.\n
va_end va_end(va_list ap) [void]\nTermination macro which must be called once after argument processing and before exit from\nfunction.\n

NULL NULL\nNull pointer constant.\n
offsetof offsetof(stype, m)\nOffset (in bytes) of member m from start of structure type `stype`.\n
ptrdiff_t ptrdiff_t\nType for objects declared to store result of subtracting pointers.\n
size_t size_t\nType for objects declared to store result of sizeof operator.\n

BUFSIZ BUFSIZ\nSize of buffer used by setbuf.\n
EOF EOF\nValue used to indicate end-of-stream or to report an error.\n
FILENAME_MAX FILENAME_MAX\nMaximum length required for array of characters to hold a filename.\n
FOPEN_MAX FOPEN_MAX\nMaximum number of files which may be open simultaneously.\n
L_tmpnam L_tmpnam\nNumber of characters required for temporary filename generated by tmpnam.\n
NULL NULL\nNull pointer constant.\n
SEEK_CUR SEEK_CUR\nValue for origin argument to fseek specifying current file position.\n
SEEK_END SEEK_END\nValue for origin argument to fseek specifying end of file.\n
SEEK_SET SEEK_SET\nValue for origin argument to fseek specifying beginning of file.\n
TMP_MAX TMP_MAX\nMinimum number of unique filenames generated by calls to tmpnam.\n
_IOFBF _IOFBF\nValue for mode argument to setvbuf specifying full buffering.\n
_IOLBF _IOLBF\nValue for mode argument to setvbuf specifying line buffering.\n
_IONBF _IONBF\nValue for mode argument to setvbuf specifying no buffering.\n
stdin stdin\nFile pointer for standard input stream. Automatically opened when program execution begins.\n
stdout stdout\nFile pointer for standard output stream. Automatically opened when program execution begins.\n
stderr stderr\nFile pointer for standard error stream. Automatically opened when program execution begins.\n
FILE FILE\nType of object holding information necessary to control a stream.\n
fpos_t fpos_t\nType for objects declared to store file position information.\n
size_t size_t\nType for objects declared to store result of sizeof operator.\n
fopen fopen(const char* filename, const char* mode) [FILE*]\nOpens file named `filename` and returns a stream, or NULL on failure. `mode` may be one of the\nfollowing for text files:\n\n   * "r": text reading\n   * "w": text writing\n   * "a": text append\n   * "r+": text update (reading and writing)\n   * "w+": text update, discarding previous content (if any)\n   * "a+": text append, reading, and writing at end\n   \nor one of those strings with b included (after the first character), for binary files.\n
freopen freopen(const char* filename, const char* mode, FILE* stream) [FILE*]\nCloses file associated with `stream`, then opens file `filename` with specified mode and\nassociates it with `stream`. Returns `stream` or NULL on error.\n
fflush fflush(FILE* stream) [int]\nFlushes stream `stream` and returns zero on success or EOF on error. Effect undefined for input\nstream. fflush(NULL) flushes all output streams.\n
fclose fclose(FILE* stream) [int]\nCloses stream `stream` (after flushing, if output stream). Returns EOF on error, zero otherwise.\n
remove remove(const char* filename) [int]\nRemoves specified file. Returns non-zero on failure.\n
rename rename(const char* oldname, const char* newname) [int]\nChanges name of file `oldname` to `newname`. Returns non-zero on failure.\n
tmpfile tmpfile() [FILE*]\nCreates temporary file (mode "wb+") which will be removed when closed or on normal program\ntermination. Returns stream or NULL on failure.\n
tmpnam tmpnam(char s[L_tmpnam]) [char*]\nAssigns to `s` (if `s` non-null) and returns unique name for a temporary file.  Unique name is\nreturned for each of the first TMP_MAX invocations.\n
setvbuf setvbuf(FILE* stream, char* buf, int mode, size_t size) [int]\nControls buffering for stream `stream`. mode is _IOFBF for full buffering, _IOLBF for line\nbuffering, _IONBF for no buffering. Non-null `buf` specifies buffer of size `size` to be used;\notherwise, a buffer is allocated. Returns non-zero on error. Call must be before any other\noperation on stream.\n
setbuf setbuf(FILE* stream, char* buf) [void]\nControls buffering for stream `stream`. For null `buf`, turns off buffering, otherwise equivalent\nto `(void)setvbuf(stream, buf, _IOFBF, BUFSIZ)`.\n
fprintf fprintf(FILE* stream, const char* format, ...) [int]\nConverts (according to format `format`) and writes output to stream `stream`.  Number of\ncharacters written, or negative value on error, is returned.  Conversion specifications consist of:\n\n  * %\n  * (optional) flag:\n    -: left adjust\n    +: always sign\n    space: space if no sign\n    0: zero pad\n    #: Alternate form: for conversion character o, first digit will be zero, for [xX], prefix 0x or\n      0X to non-zero value, for [eEfgG], always decimal point, for [gG] trailing zeros not removed.\n  * (optional) minimum width: if specified as *, value taken from next argument (which must\n    be int).\n  * (optional) . (separating width from precision):\n  * (optional) precision: for conversion character s, maximum characters to be printed from the\n    string, for [eEf], digits after decimal point, for [gG], significant digits, for an integer,\n    minimum number of digits to be printed.  If specified as *, value taken from next argument\n    (which must be int).\n  * (optional) length modifier:\n    h: short or unsigned short\n    l: long or unsigned long\n    L: long double\n  * conversion character:\n    d,i: int argument, printed in signed decimal notation\n    o: int argument, printed in unsigned octal notation\n    x,X: int argument, printed in unsigned hexadecimal notation\n    u: int argument, printed in unsigned decimal notation\n    c: int argument, printed as single character\n    s: char* argument\n    f: double argument, printed with format [-]mmm.ddd\n    e,E: double argument, printed with format [-]m.dddddd(e|E)(+|-)xx\n    g,G: double argument\n    p: void* argument, printed as pointer\n    n: int* argument : the number of characters written to this point is written into argument\n    %: no argument; prints %\n
printf printf(const char* format, ...) [int]\nprintf(f, ...) is equivalent to fprintf(stdout, f, ...)\n
sprintf sprintf(char* s, const char* format, ...) [int]\nLike fprintf, but output written into string `s`, which *must be large enough to hold the output*,\nrather than to a stream. Output is NUL-terminated. Returns length (excluding the terminating NUL).\n
vfprintf vfprintf(FILE* stream, const char* format, va_list arg) [int]\nEquivalent to fprintf with variable argument list replaced by `arg`, which must have been\ninitialised by the va_start macro (and may have been used in calls to va_arg).\n
vprintf vprintf(const char* format, va_list arg) [int]\nEquivalent to printf with variable argument list replaced by `arg`, which must have been\ninitialised by the va_start macro (and may have been used in calls to va_arg).\n
vsprintf vsprintf(char* s, const char* format, va_list arg) [int]\nEquivalent to sprintf with variable argument list replaced by `arg`, which must have been\ninitialised by the va_start macro (and may have been used in calls to va_arg).\n
fscanf fscanf(FILE* stream, const char* format, ...) [int]\nPerforms formatted input conversion, reading from stream `stream` according to format `format`. The\nfunction returns when `format` is fully processed. Returns number of items converted and assigned,\nor EOF if end-of-file or error occurs before any conversion. Each of the arguments following\nformat *must be a pointer*. Format string may contain:\n\n  * blanks and tabs, which are ignored\n  * ordinary characters, which are expected to match next non-white-space of input\n  * conversion specifications, consisting of:\n    * %\n    * (optional) assignment suppression character "*"\n    * (optional) maximum field width\n    * (optional) target width indicator:\n      h: argument is pointer to short rather than int\n      l: argument is pointer to long rather than int, or double rather than float\n      L: argument is pointer to long double rather than float\n    * conversion character:\n      d: decimal integer; int* parameter required\n      i: integer; int* parameter required; decimal, octal or hex\n      o: octal integer; int* parameter required\n      u: unsigned decimal integer; unsigned int* parameter required\n      x: hexadecimal integer; int* parameter required\n      c: characters; char* parameter required; white-space is not skipped, and NUL-termination is\n         not performed\n      s: string of non-white-space; char* parameter required; string is NUL-terminated\n      e,f,g: floating-point number; float* parameter required\n      p: pointer value; void* parameter required\n      n: chars read so far; int* parameter required\n      [...]: longest non-empty string from specified set; char* parameter required; string is\n        NUL-terminated\n      [^...]: longest non-empty string not from specified set; char* parameter required; string is\n        NUL-terminated\n      %: literal %; no assignment\n
scanf scanf(const char* format, ...) [int]\nscanf(f, ...) is equivalent to fscanf(stdin, f, ...)\n
sscanf sscanf(char* s, const char* format, ...) [int]\nLike fscanf, but input read from string `s`.\n
fgetc fgetc(FILE* stream) [int]\nReturns next character from (input) stream `stream`, or EOF on end-of-file or error.\n
fgets fgets(char* s, int n, FILE* stream) [char*]\nCopies characters from (input) stream `stream` to `s`, stopping when `n`-1 characters copied,\nnewline copied, end-of-file reached or error occurs. If no error, `s` is NUL-terminated. Returns\nNULL on end-of-file or error, `s` otherwise.\n
fputc fputc(int c, FILE* stream) [int]\nWrites `c`, to stream `stream`. Returns `c`, or EOF on error.\n
fputs fputs(const char* s, FILE* stream) [char*]\nWrites `s`, to (output) stream `stream`. Returns non-negative on success or EOF on error.\n
getc getc(FILE* stream) [int]\nEquivalent to fgetc except that it may be a macro.\n
getchar getchar(void) [int]\nEquivalent to getc(stdin).\n
gets gets(char* s) [char*]\nCopies characters from stdin into `s` until newline encountered, end-of-file reached, or error\noccurs. Does not copy newline. NUL-terminates `s`. Returns `s`, or NULL on end-of-file or\nerror. *Should not be used because of the potential for buffer overflow.*\n
putc putc(int c, FILE* stream) [int]\nEquivalent to fputc except that it may be a macro.\n
putchar putchar(int c) [int]\nputchar(c) is equivalent to putc(c, stdout).\n
puts puts(const char* s) [int]\nWrites `s` (excluding terminating NUL) and a newline to stdout. Returns non-negative on success,\nEOF on error.\n
ungetc ungetc(int c, FILE* stream) [int]\nPushes `c` (which must not be EOF), onto (input) stream `stream` such that it will be returned\nby the next read. Only one character of pushback is guaranteed (for each stream). Returns `c`,\nor EOF on error.\n
fread fread(void* ptr, size_t size, size_t nobj, FILE* stream) [size_t]\nReads (at most) `nobj` objects of size `size` from stream `stream` into `ptr` and returns number\nof objects read. (feof and ferror can be used to check status.)\n
fwrite fwrite(const void* ptr, size_t size, size_t nobj, FILE* stream) [size_t]\nWrites to stream `stream`, `nobj` objects of size `size` from array `ptr`.  Returns number of\nobjects written.\n
fseek fseek(FILE* stream, long offset, int origin) [int]\nSets file position for stream `stream` and clears end-of-file indicator. For a binary stream,\nfile position is set to `offset` bytes from the position indicated by `origin`: beginning of file\nfor SEEK_SET, current position for SEEK_CUR, or end of file for SEEK_END. Behaviour is similar\nfor a text stream, but `offset` must be zero or, for SEEK_SET only, a value returned by ftell.\nReturns non-zero on error.\n
ftell ftell(FILE* stream) [long]\nReturns current file position for stream `stream`, or -1 on error.\n
rewind rewind(FILE* stream) [void]\nEquivalent to fseek(stream, 0L, SEEK_SET); clearerr(stream).\n
fgetpos fgetpos(FILE* stream, fpos_t* ptr) [int]\nStores current file position for stream `stream` in `*ptr`. Returns non-zero on error.\n
fsetpos fsetpos(FILE* stream, const fpos_t* ptr) [int]\nSets current position of stream `stream` to `*ptr`. Returns non-zero on error.\n
clearerr clearerr(FILE* stream) [void]\nClears end-of-file and error indicators for stream `stream`.\n
feof feof(FILE* stream) [int]\nReturns non-zero if end-of-file indicator is set for stream `stream`.\n
ferror ferror(FILE* stream) [int]\nReturns non-zero if error indicator is set for stream `stream`.\n
perror perror(const char* s) [void]\nPrints `s` (if non-null) and strerror(errno) to standard error as would:\n\n  fprintf(stderr, "%s: %s\n", (s != NULL ? s : ""), strerror(errno))\n

EXIT_FAILURE EXIT_FAILURE\nValue for status argument to exit indicating failure.\n
EXIT_SUCCESS EXIT_SUCCESS\nValue for status argument to exit indicating success.\n
RAND_MAX RAND_MAX\nMaximum value returned by rand().\n
NULL NULL\nNull pointer constant.\n
div_t div_t\nReturn type of div().\n
quot div_t.quot [int]\nquotient\n
rem div_t.rem [int]\nremainder\n
ldiv_t ldiv_t\nReturn type of ldiv().\n
qout ldiv_t.quot [long]\nquotient\n
rem ldiv_t.rem [long]\nremainder\n
size_t size_t\nType for objects declared to store result of sizeof operator.\n
abs abs(int n) [int]\n
labs labs(long n) [long]\nReturns absolute value of `n`.\n
div div(int num, int denom) [div_t]\n
ldiv ldiv(long num, long denom) [ldiv_t]\nReturns quotient and remainder of `num`/`denom`.\n
atof atof(const char* s) [double]\nEquivalent to strtod(s, (char**)NULL) except that errno is not necessarily set on conversion error.\n
atoi atoi(const char* s) [int]\nEquivalent to (int)strtol(s, (char**)NULL, 10) except that errno is not necessarily set on\nconversion error.\n
atol atol(const char* s) [long]\nEquivalent to strtol(s, (char**)NULL, 10) except that errno is not necessarily set on conversion\nerror.\n
strtod strtod(const char* s, char** endp) [double]\nConverts initial characters (ignoring leading white space) of `s` to type double. If `endp`\nnon-null, stores pointer to unconverted suffix in `*endp`. On overflow, sets errno to ERANGE and\nreturns HUGE_VAL with the appropriate sign; on underflow, sets errno to ERANGE and returns zero;\notherwise returns converted value.\n
strtol strtol(const char* s, char** endp, int base) [long]\nConverts initial characters (ignoring leading white space) of `s` to type long.  If `endp`\nnon-null, stores pointer to unconverted suffix in `*endp`. If base between 2 and 36, that base\nused for conversion; if zero, leading (after any sign) 0X or 0x implies hexadecimal, leading 0\n(after any sign) implies octal, otherwise decimal assumed. Leading 0X or 0x permitted for base\nhexadecimal. On overflow, sets errno to ERANGE and returns LONG_MAX or LONG_MIN (as appropriate\nfor sign); otherwise returns converted value.\n
strtoul strtoul(const char* s, char** endp, int base) [unsigned long]\nAs for strtol except result is unsigned long and value on overflow is ULONG_MAX.\n
calloc calloc(size_t nobj, size_t size) [void*]\nReturns pointer to _zero-initialised_ newly-allocated space for an array of `nobj` objects each\nof size `size`, or NULL on error.\n
malloc malloc(size_t size) [void*]\nReturns pointer to _uninitialised_ newly-allocated space for an object of size `size`, or NULL\non error.\n
realloc realloc(void* p, size_t size) [void*]\nReturns pointer to newly-allocated space for an object of size `size`, initialised, to minimum\nof old and new sizes, to existing contents of `p` (if non-null), or NULL on error. On success,\nold object deallocated, otherwise unchanged.\n
free free(void* p) [void]\nIf `p` non-null, deallocates space to which it points.\n
abort abort() [void]\nTerminates program abnormally, by calling raise(SIGABRT).\n
exit exit(int status) [void]\nTerminates program normally. Functions installed using atexit are called (in reverse order to\nthat in which installed), open files are flushed, open streams are closed and control is returned\nto environment. `status` is returned to environment in implementation-dependent manner. Zero or\nEXIT_SUCCESS indicates successful termination and EXIT_FAILURE indicates unsuccessful termination.\nImplementations may define other values.\n
atexit atexit(void (*fcm)(void)) [int]\nRegisters `fcn` to be called when program terminates normally (or when main returns). Returns\nnon-zero on failure.\n
system system(const char* s) [int]\nIf `s` is not NULL, passes `s` to environment for execution, and returns reported by command\nprocessor; if `s` is NULL, non-zero returned if environment has a command processor.\n
getenv getenv(const char* name) [char*]\nReturns string associated with name `name` from implementation's environment, or NULL if no\nsuch string exists.\n
bsearch bsearch(const void* key, const void* base, size_t n, size_t size, int (*cmp)(const void* keyval, const void* datum)) [void*]\nSearches ordered array `base` (of `n` objects each of size `size`) for item matching key according\nto comparison function `cmp`. `cmp` must return negative value if first argument is less than\nsecond, zero if equal and positive if greater. Items of `base` are assumed to be in ascending\norder (according to `cmp`). Returns a pointer to an item matching `key`, or NULL if none found.\n
qsort qsort(void* base, size_t n, size_t size, int (*cmp)(const void*, const void*)) [void]\nArranges into ascending order array `base` (of `n` objects each of size `size`) according to\ncomparison function `cmp`. `cmp` must return negative value if first argument is less than\nsecond, zero if equal and positive if greater.\n
rand rand(void) [int]\nReturns pseudo-random number in range 0 to RAND_MAX.\n
srand srand(unsigned int seed) [void]\nUses seed as seed for new sequence of pseudo-random numbers. Initial seed is 1.\n

NULL NULL\nNull pointer constant.\n
size_t size_t\nType for objects declared to store result of sizeof operator.\n
strcpy strcpy(char* s, const char* ct) [char*]\nCopies `ct` to `s` including terminating NUL and returns `s`.\n
strncpy strncpy(char* s, const char* ct, size_t n) [char*]\nCopies at most `n` characters of `ct` to `s`. Pads with NUL characters if `ct` is of length\nless than `n`. *Note that this may leave `s` without NUL-termination.* Return `s`.\n
strcat strcat(char* s, const char* ct) [char*]\nConcatenate `ct` to `s` and return `s`.\n
strncat strncat(char* s, const char* ct, size_t n) [char*]\nConcatenate at most `n` characters of `ct` to `s`. NUL-terminates `s` and return it.\n
strcmp strcmp(const char* cs, const char* ct) [int]\nCompares `cs` with `ct`, returning negative value if `cs`<`ct`, zero if `cs`==`ct`, positive\nvalue if `cs`>`ct`.\n
strncmp strncmp(const char* cs, const char* ct, size_t n) [int]\nCompares at most (the first) `n` characters of `cs` and `ct`, returning negative value if\n`cs`<`ct`, zero if `cs`==`ct`, positive value if `cs`>`ct`.\n
strcoll strcoll(const char* cs, const char* ct) [int]\nCompares `cs` with `ct` according to locale, returning negative value if `cs`<`ct`, zero if\n`cs`==`ct`, positive value if `cs`>`ct`.\n
strchr strchr(const char* cs, int c) [char*]\nReturns pointer to first occurrence of `c` in `cs`, or NULL if not found.\n
strrchr strrchr(const char* cs, int c) [char*]\nReturns pointer to last occurrence of `c` in `cs`, or NULL if not found.\n
strspn strspn(const char* cs, const char* ct) [size_t]\nReturns length of prefix of `cs` which consists of characters which are in `ct`.\n
strcspn strcspn(const char* cs, const char* ct) [size_t]\nReturns length of prefix of `cs` which consists of characters which are not in `ct`.\n
strpbrk strpbrk(const char* cs, const char* ct) [char*]\nReturns pointer to first occurrence in `cs` of any character of `ct`, or NULL if none is found.\n
strstr strstr(const char* cs, const char* ct) [char*]\nReturns pointer to first occurrence of `ct` within `cs`, or NULL if none is found.\n
strlen strlen(const char* cs) [size_t]\nReturns length of `cs`.\n
strerror strerror(int n) [char*]\nReturns pointer to implementation-defined message string corresponding with error `n`.\n
strtok strtok(char* s, const char* t) [char*]\nSearches `s` for next token delimited by any character from `ct`. Non-NULL `s` indicates the\nfirst call of a sequence. If a token is found, it is NUL-terminated and returned, otherwise\nNULL is returned. `ct` need not be identical for each call in a sequence.\n
strxfrm strxfrm(char* s, const char* ct, size_t n) [size_t]\nStores in `s` no more than `n` characters (including terminating NUL) of a string produced from\n`ct` according to a locale-specific transformation. Returns length of entire transformed string.\n
memcpy memcpy(void* s, const void* ct, size_t n) [void*]\nCopies `n` characters from `ct` to `s` and returns `s`. *`s` may be corrupted if objects overlap.*\n
memmove memmove(void* s, const void* ct, size_t n) [void*]\nCopies `n` characters from `ct` to `s` and returns `s`. *`s` will not be corrupted if objects\noverlap.*\n
memcmp memcmp(const void* cs, const void* ct, size_t n) [int]\nCompares at most (the first) `n` characters of `cs` and `ct`, returning negative value if\n`cs`<`ct`, zero if `cs`==`ct`, positive value if `cs`>`ct`.\n
memchr memchr(const void* cs, int c, size_t n) [void*]\nReturns pointer to first occurrence of `c` in first `n` characters of `cs`, or NULL if not found.\n
memset memset(void* s, int c, size_t n) [void*]\nReplaces each of the first `n` characters of `s` by `c` and returns `s`.\n

CLOCKS_PER_SEC CLOCKS_PER_SEC\nThe number of clock_t units per second.\n
NULL NULL\nNull pointer constant.\n
clock_t clock_t\nAn arithmetic type elapsed processor representing time.\n
time_t time_t\nAn arithmetic type representing calendar time.\n
tm tm [struct]\nRepresents the components of calendar time. Implementations may change field order and include\nadditional fields.\n
tm_set tm.tm_sec [int]\nseconds after the minute\n
tm_min tm.tm_min [int]\nminutes after the hour\n
tm_hour tm.tm_hour [int]\nhours since midnight\n
tm_mday tm.tm_mday [int]\nday of the month\n
tm_mon tm.tm_mon [int]\nmonths *since* January\n
tm_year tm.tm_year [int]\nyears since 1900\n
tm_wday tm.tm_wday [int]\ndays since Sunday\n
tm_yday tm.tm_yday [int]\ndays since January 1\n
tm_isdst tm.tm_isdst [int]\nDaylight Saving Time flag : is positive if DST is in effect, zero if not in effect, negative\nif information not known.\n
clock clock(void) [clock_t]\nReturns elapsed processor time used by program or -1 if not available.\n
time time(time_t* tp) [time_t]\nReturns current calendar time or -1 if not available. If `tp` is non-NULL, return value is also\nassigned to `*tp`.\n
difftime difftime(time_t time2, time_t time1) [double]\nReturns the difference in seconds between `time2` and `time1`.\n
mktime mktime(struct tm* tp) [time_t]\nIf necessary, adjusts fields of `*tp` to fall withing normal ranges. Returns the corresponding\ncalendar time, or -1 if it cannot be represented.\n
asctime asctime(const struct tm* tp) [char*]\nReturns the given time as a string of the form:\n\n  Sun Jan 3 13:08:42 1988\0\n
ctime ctime(const time_t* tp) [char*]\nReturns string equivalent to calendar time `tp` converted to local time.  Equivalent to:\nasctime(localtime(tp))\n
gmtime gmtime(const time_t* tp) [struct tm*]\nReturns calendar time `*tp` converted to Coordinated Universal Time, or NULL if not available.\n
localtime localtime(const time_t* tp) [struct tm*]\nReturns calendar time `*tp` converted into local time.\n
strftime strftime(char* s, size_t smax, const char* fmt, const struct tm* tp) [size_t]\nFormats `*tp` into `s` according to `fmt`. Places no more than `smax` characters into `s`,\nand returns number of characters produced (excluding terminating NUL), or 0 if greater than\n`smax`. Formatting conversions (`%c`) are:\n\n  * A: name of weekday\n  * a: abbreviated name of weekday\n  * B: name of month\n  * b: abbreviated name of month\n  * c: local date and time representation\n  * d: day of month [01-31]\n  * H: hour (24-hour clock) [00-23]\n  * I: hour (12-hour clock) [01-12]\n  * j: day of year [001-366]\n  * M: minute [00-59]\n  * m: month [01-12]\n  * p: local equivalent of "AM" or "PM"\n  * S: second [00-61]\n  * U: week number of year (Sunday as 1st day of week) [00-53]\n  * W: week number of year (Monday as 1st day of week) [00-53]\n  * w: weekday (Sunday as 0) [0-6]\n  * X: local time representation\n  * x: local date representation\n  * Y: year with century\n  * y: year without century [00-99]\n  * Z: name (if any) of time zone\n  * %: %\n\nLocal time may differ from calendar time because of time zone.\n
